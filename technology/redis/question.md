1. 整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？
- 内存利用率，整数数组和压缩列表都是非常紧凑的数据结构，比链表占用更少的内存空间，redis是内存数据库，大量数据存在内存，此时需要尽可能的优化，提高内存利用率。
- 数组对cpu高速缓存支持更友好，所以在redis设计时，集合元素较少的情况下，默认采用内存紧凑排列的方式进行存储，同时利用cpu高速缓存不会降低访问速率。当数据元素超过设定阈值时，为了提高查询效率，转为采用hash和跳表进行数据存储。
    - 如果在数组上进行随机访问，对cpu高速缓存是否还友好？
    - Redis底层使用数组和压缩链表对数据大小限制在64个字节以下，当大于64个字节会改变存储数据的数据结构，所以随机访问对于CPU高速缓存没啥影响
2. redis是单线程吗？
- redis的单线程主要是指redis的网络IO和键值对读写是由一个线程完成的，这也是redis对外提供键值存储的主要流程，但是redis的其他功能，比如持久化，异步删除，集群数据同步等，都是由另外的线程完成的  
3. 为什么redis采用单线程？
- 多线程编程模式面临着共享资源的并发访问控制问题，如果没有精细的设计，可能会出现不理想的结果
（等待共享数据结构，并行变串行）；并且多线程开发一般会引入同步原语来保护共享资源的并发访问，也会降
系统代码的易调试性和可维护性。
4. redis为什么那么快？
- redis的大部分操作都是在内存上完成的，再加上它采用来高效的数据结构（哈希表，跳表）
- redis采用来多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率
5. redis单线程处理IO请求性能瓶颈？
- 任意一个请求在server中一旦发生耗时，都会影响整个server的性能，后面的请求都要等前面的请求处理完
之后自己才能被处理，耗时操作包括以下几种：
  - 操作bigkey：写入一bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样产生耗时
  - 使用复杂度过高的命令：sort/sunion/zunionstore，或者O（N）命令，但是N很大
  - 大量key集中过期：redis的过期机制也是在主线程中执行的，大量的key集中过期会导致处理一个请求时，耗时都在
  删除过期key，耗时变长
  - 淘汰策略：淘汰策略也是在主线程中执行的，当内存超过redis内存上限后，每次写入都需要淘汰一些key，也会
  造成耗时
  - AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢redis性能
  - 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但是fork这一瞬间也会阻塞整个线程，实例越大，阻塞时间越久
- 并发量大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步
IO（不是指直接整个网络IO同步，而是从内核到缓冲区拷贝数据的操作），只能单线程依次读取客户端的数据，无法利用到CPU多核。  
针对第一点，需要业务人员区规避，redis4.0推出lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程，降低对主线程的影响。  
针对第二点，redis6.0推出可多线程，可以在高并发场景下利用cpu多核多线程读写客户端数据，进一步提升server性能，当然，只是针对
客户端的读写是并行的，每个命令真正的操作依旧是单线程的。